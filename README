# Beastmaker Game Adaptation

This project adapts the Beastmaker game from Garth Nix's *Seventh Tower* series. Some changes were made from the 
source text, which are explained in the **lore notes** file. Meanwhile, notes about how the game was implemented and
the reasons for decisions made are in the **technical notes** file. No infringements intended.

---

## How to Run

To play a game:

1. **Download and unzip** the codebase.
2. **Open the command line interface** (cmd on Windows).
3. **Navigate to the folder** containing the files.
4. Run the game using: run the run.py file.
There are places for 3 options - which scoring system to use (p or b for points or battle), 
and who the players should be (s for static AI, m for monte carlo ai, h for human).
For example, "python run.py p s h" would start a game using points socring with a static AI playing first
and the human playing second.

How to Play:

The game of Beastmaker involves 2 players playing cards in different categories to create a creature. 
In the book, the 2 creatures are then simulated and battle (with the winner of the fight determining the winner of the game).
The actual gameplay happens over the course of a series of rounds. 
Each round, a player will draw a card and choose a slot (corresponding to a category) to play it in. 
Players go back and forth until they each have filled all 7 slots on their board 
(Head, Heart,Temper, Skin, Strength, Speed, and Special). 
Each card will have a list of 3 creatures (aka variations) on it. A card can be played in any open slot in any
variation 
(though it is set once played, and only uses the stat of the chosen variation in the category of the slot in which it was played).
Each variation will have different stats for each category, and the idea is to play cards in categories where they have high stats. 
Stats were generated according to a binomial distribution, but with different means and variances.
This means that the Heart stat, for example, will nearly always be higher than the Special Stat, 
but the creature will need to have 1 card in each category, so it is not always best to just a play a card in 
whatever category it has the raw highest number for (i.e. a 55 in Special might be more valuable than a 65 in 
Heart since both slots will need to be filled anyways, and Special tends to have lower values).
To play a card, first write the slot in which you wish to play it, 
and then write the variation number you wish to play the card in.

To adjust mechanics, variables available for tweaking are in tuning.py.

Create New Deck:

Follow the first few steps as how to run, but actually run create_deck.py. Warning - this will get rid of all variation .names

Scoring:

There are two forms of scoring systems. The first is points based. This simply compares the two result creatures based
on their values in each category and gives points based on the difference (higher is better). 
It should be noted that the points given for a category is based both on the raw margin between the result creatures's stats 
and how high the stats were. For example, if player A's creature had a Temper and Strength of 60
while Player B's had a Temper of 40 and Strength of 80, A would get more points. 
Even though both have the same margin, since the raw stats were lower for Temper than Strength, 
it is weighted heavier. See technical notes or the code for more details. 

The other form of scoring is battle based. In this version, the two creatures are roughly simulated and battle
each other until a winner is decided. If they knock each other out in the same round, 
the winner is whoever's creatures HP was less negative.

AI:

There are two AI's available to play against. The first is Static AI, which simply plays cards
based on what the highest relative stat they have (i.e. what percentile the card is each category).
The second is Monte Carlo AI, which creates a Monte Carlo Search Tree to simulate games to decide where to play
a card each turn. This AI can take much longer than Static AI, but is also generally a bit better of a player.
The amount of time it takes (which scales conversely with its skill) can be adjusted in the tuning.py file
with the variable 'num_simulations'.

File Descriptions:

ai.py - Functions for AI behavior and descision making
classes.py - Structure for Deck and Player classes
create_deck - wrapper for deck_creator.py
deck_creator - functions to create a new deck and show its distribution
game.py - central game loop 
run.py - wrapper for game.py
scoring.py - functions describing how to score the game
tuning.py - file with all hardcoded variables for potential tuning for game balance
